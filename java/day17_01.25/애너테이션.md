## 출처 : 자바의 정석
# 애너테이션(Annotation)
## 애너테이션이란?
- 주석과 마찬가지로 프로그래밍 언어(소스코드)에 영향을 미치지 않고 컴파일러에게 **정보 제공**을 목적으로 사용된다.
<br><br>

## 표준 애너테이션
- JDK에서 제공하는 애너테이션, 주로 컴파일러를 위한 정보를 제공한다.

### @Override
메서드 -> @Override -> 컴파일러에게 이 메서드가 오버라이드 된 메서드라는 정보 제공 -> 컴파일러가 부모 클래스 메서드 확인
-> 없으면 에러 메세지 출력, 있으면 정상 실행
- 메서드 앞에 붙음.
- 부모의 메서드를 오버라이딩 한 메서드라는 것을 컴파일러에게 정보 제공하는 역할.
- 컴파일러가 같은 이름의 메서드가 조상에 있는지 확인하고 없으면, 에러 메세지를 출력한다.
- 알아내기 어려운 실수를 미연에 방지해주기 위해 사용.

### @Deprecated
- 더 이상 사용되지 않는 필드나 메서드에 붙음.
- 붙은 대상은 다른 것으로 대체되었으니 더 이상 사용하지 않을 것을 권한다는 의미.
- 컴파일 시 메세지가 발생하지만 강제성은 없기 때문에 컴파일 및 실행이 된다.

### @FunctionalInterface
- 함수형 인터페이스 선언 시 붙음.
- 컴파일러가 함수형 인터페이스를 올바르게 선언했는지 확인하고 잘못된 경우 에러 메세지 발생.
- 실수 방지를 위해 사용.

### @SuppressWarnings
- 컴파일러가 컴파일 시 보여주는 경고 메세지가 나타나지 않게 억제.
- 확인 후 해결하여 컴파일 시 어떠한 메세지도 나타나지 않도록 해야한다.
- 하지만, 묵인해야하는 경고가 발생한 경우 @SuppressWarnings를 붙여서 컴파일 후에
  어떠한 경고 메세지도 나타나지 않도록 해야한다.
- 종류
    - deprecation : @Deprecated가 붙은 대상을 사용해서 발생하는 경고 메세지
    - unchecked : 지네릭스로 타입을 지정하지 않은 경우 발생하는 경고 메세지
    - rawtypes : 지네릭스를 사용하지 않아서 발생하는 경고 메세지
    - varargs : 가변인자의 타입이 지네릭 타입일 경우 발생하는 경고 메세지
- ※주위※ 둘 이상의 경고를 동시 억제 시 배열처럼 중괄호{}를 추가 사용해야한다.
` @SuppressWarnings ({"deprecation","unchecked","varargs"})`
- 하지만 일반적으로 해당 대상에만 애너테이션을 붙여서 경고의 억제 범위를 최소화 하는것이 좋다.
    - 추후에 추가되는 코드에서 발생할 수 있는 경고 메세지까지 함께 억제되기 때문이다.

### @SafeVarargs
- 메서드에 선언된 가변인자의 타입이 non-reifiable 타입인 경우, 해당 메서드를 선언하는 부분과 호출
  하는 부분에서 unchecked 경고가 발생한다.
    - 컴파일 후에도 제거되지 않는 타입을 'reifiable 타입', 제거되는 타입을 'non-reifiable 타입'이라 한다.
    - 지네릭 타입은 대부분 제거되므로 non-reifiable 타입이다.
- 이 애너테이션은 오버라이드가 가능한 메서드에서는 사용할 수 없다.
- 메서드를 선언하는 곳에 이 애너테이션을 붙이면, 호출하는 곳에서도 경고가 억제된다.
- @SafeVarargs 대신 @SuppressWarnings("unchecked")로 경고 억제 시, 메서도 선언부 및 호출부에 붙여줘야 한다.
- @SafeVarargs는 unchecked 경고는 억제 가능하지만 varargs 경고는 억제 불가하므로 습관적으로 @SafeVarargs와
  @SuppressWarnings("varargs")는 같이 붙여 쓴다.

## 메타 에너테이션
 - 애너테이션을 위한 애너테이션.
 - 애너테이션 정의 시, 적용 대상이나 유지 기간 등을 지정하는데 사용하는 애너테이션.
  
### @Target
 - 적용 가능 대상 지정.
  
 #### 애너테이션 적용대상의 종류
 - ANNOTATION_TYPE : 애너테이션
 - CONSTRUCTOR : 생성자
 - FIELD : 필드(멤버변수, enum 상수) *기본 타입
 - LOCAL_VARIABLE : 지역변수
 - METHOD : 메서드
 - PACKAAGE : 패키지
 - PARAMETER : 매개변수
 - TYPE : 타입(클래스, 인터페이스, enum)
 - TYPE_PARAMETER : 타입 매개변수
 - TYPE_USE : 타입이 사용되는 모든 곳. * 참조 타입

### @Retention
 - 유지되는 기간 지정.

 #### 애너테이션 유지정책의 종류
 - SOURCE : 소스파일에만 존재.(클래스 파일 X)
 - CLASS : 기본값, 클래스 파일에 존재, 실행 시 사용 불가.
    - 클래스 파일이 JVM에 로딩될 때 애너테이션의 정보가 무시되어 실행 시 정보 확인이 불가하다는 한계.
    - 기본값임에도 잘 사용하지 않음.
 - RUNTIME : 클래스 파일에 존재, 실행시 사용가능.
    - 가장 많이 사용됨.
    - 실행 시 리플렉션을 통해 클래스 파일에 저장된 애너테이션의 정보를 읽어 처리할 수 있다.

### @Documented
 - 애너테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록 함.

### Inherited
 - 자식 클래스에 애너테이션이 상속되도록 한다.
 - @Inherited가 붙은 애너테이션을 상위 클래스에 붙이면, 하위 클래스에도 이 애너테이션이 붙은것과 같아진다.

### Repeatable
 - 일반적으로 하나의 대상에 한 종류의 애너테이션을 붙일 수 있다.
 - 하지만, @Repeatable 이 붙은 애너테이션은 한대상에 여러개 붙일 수 있다.
 - 이 애너테이션의 경우 여러 애너테이션을 하나로 묶어서 다룰 수 있는 애너테이션을 추가로 정의해야 한다.
    - 이러한 애너테이션을 컨테이너 애너테이션이라고 한다.
 ` @interface ToDos { ToDo[] value(); }`

 ```
@Repeatable(ToDos.class) // 컨테이너 애너테이션
@interface ToDo{
    String value();
}

@ToDo("ABC")
@ToDo("DEF")
class MyClass{ ... }
 ```

## 애너테이션 타입 정의
- 애너테이션 정의
```
@interface 애너테이션명 {
    타입 요소이름(); // 애너테이션의 요소를 선언
    ...
}

```
- 애너테이션의 요소로 자신이 아닌 다른 애너테이션을 포함할 수 있다.