# Java 컴파일 과정
- 자바는 플렛폼의 독립성이라는 큰 특징을 갖는다.
- 가능한 이유는 JVM을 사용하기 때문인데, 그렇다면
  어떠한 기능을 통해서 플렛폼으로부터 독립성을 갖게
  되는지 자바 컴파일 과정을 통해 알아보자.

# java 컴파일 순서
### 컴파일 타임 환경
1. 자바 소스코드(.java) 작성
2. 자바 컴파일러가 자바 소스파일을 컴파일해준다.
    - 컴파일한 파일은 자바 **바이트코드**라고 해서
      .class 파일을 말한다.

### 자바 런타임 환경
3. 컴파일 된 바이트 코드를 JVM의 클래스 로더로 보내 준다.
    - <a href="C:\Users\dbe12\OneDrive\바탕 화면\review\java\헤깔리는 개념 정리\클래스로더.md">클래스 로더에 대한 설명</a>
4. 클래스 로더는 동적로딩을 통해 필요한 클래스들을 로딩 및 링크하여 JVM의 메모리 중
   하나인 런타임 데이터 영역에 로드한다.
   - 클래스 로더 세부 동작(간단히)
        1. 로드 : 클래스 파일을 JVM 메모리에 로드.
        2. 검증 : 자바언어명세(Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사.
        3. 준비 : 클래스에서 필요로 하는 메모리를 할당(필드, 메서드, 인터페이스 ...)
        4. 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경.
          - 심볼릭 레퍼런스는 컴파일 시 참조변수에 대입되는 임시 주소정도로 생각하면된다.
            실행 시 JVM에 의해서 실제 주소값인 다이렉트 레퍼런스로 변경된다.
        5. 초기화 : 클래스 정적 요소들을 적절한 값으로 초기화 해준다.
5. 실행엔진(Execution Engine)은 JVM 메모리에 올바른 바이트 코드들을 명령어 단위로 하나씩 가져와 실행.
   이때, 실행엔진은 두가지 방식으로 변경한다.
    - 인터 프리터 : 바이트 코드를 한줄씩 읽어 해석 및 실행. 하나하나의 실행은 빠르나, 전체적인 실행 속도는
      느리다.
    - JIT(Just-In-Time) Compiler : 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를
      컴파일하여 바이너리 코드 로 변경하고 이후에는 해당 메서드를 더 이상 인터프리팅 하지않고, 바이너리 코
      드를 직접 실행하는 방식. 하나씩 실행하는 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파
      일된 바이너리 코드를 실행하는 것이므로 전체적인 속도는 인터프리팅 방식보다 빠른편이다.