### 2023.01.30. 2일차
# 쓰레드의 우선순위
- 쓰레드는 우선순위라는 속성(멤버변수)을 가지고 있는데, 이 우선순위의 값에 따라 쓰레드가 얻는 실행 시간이 달라진다.
- 쓰레드는 작업의 중요도에 따라서 우선순위를 서로 다르게 하여 다른 작업시간을 갖도록 할 수 있다.<br>
## 쓰레드의 우선순위 지정
```
void setPriorty(int newPriorty) // 쓰레드의 우선순위를 지정한 값으로 변경.
int getPriority() // 쓰레드의 우선순위를 반환.
```
- 우선순위 범위는 1 ~ 10까지이며, 숫자가 높을수록 우선순위가 높다.
- 우선순위는 쓰레드를 생성한 쓰레드로부터 상속 받는다.
    - Ex) 메인 메서드를 수행하는 쓰레드는 우선순위가 5이므로, 메인 메서드 내에서 생성한 쓰레드의 우선순위도 5이다.
- ***우선순위는 쓰레드를 실행하기 전에만 변경이 가능하다.***

### ※참고※
- 쓰레드 우선순위 예제 실행 시 결과 확인을 확실하게 하기 위해 아무일도 하지 않는 반복문을 추가하여 작업 지연을 시킨다.
` for(int x = 0;x < 10000000; x++);`<br>
#### ★ 멀티코어에서는 쓰레드의 우선순위에 따른 차이가 거의 없다.
- 따라서, 요즘 시대(멀티코어)에 우선순위 지정은 크게 의미없다.<br><br>

# 쓰레드 그룹
## 1. 쓰레드 그룹이란?
- 서로 관련된 그룹으로 묶어 관리하기 위한 것.
- 사실 보안상의 이유로 도입된 개념으로, 자신이 속한 쓰레드는 그룹이나 하위 쓰레드 그룹은 변경할 수 있지만, 다른 쓰레드 그룹의 쓰레드는 변경 불가.<br>
## 2. 주요 생성자와 메서드
- ThreadGroup(String name) : 지정된 이름의 새로운 쓰레드 그룹 생성.
- TrheadGroup(ThreadGroup parent, String name) : 지정된 쓰레드 그룹에 포함(하위)되는 새로운 쓰레드 그룹을 지정된 이름으로 생성.
- int activeCount() : 쓰레드 그룹에 포함된 활성상태에 있는 쓰레드의 수를 반환.
- int activeGroupCount() : 쓰레드 그룹에 포함된 활성상태에 있는 쓰레드 그룹의 수를 반환.
- 쓰레드를 쓰레드 그룹에 포함시키려면 Thread의 생성자를 사용해야 한다.
```
Thread(ThreadGroup group, String name)
Thread(ThreadGroup group, String name, Runnable target)
Thread(ThreadGroup group, String name, Runnable target, String name)
Thread(ThreadGroup group, String name, Runnable target, String name, long stackSize)
```
## 3. main 쓰레드 그룹
- ***모든 쓰레드는 반드시 그룹에 포함되어 있어야한다.***
- ***그룹을 지정하는 생성자를 사용하지 않은 쓰레드는 기본적으로 자신을 생성한 쓰레드와 같은 쓰레드 그룹에 속하게 된다.***
- 자바 어플리케이션이 실행되면, JVM에 의해 main과 system이라는 쓰레드 그룹이 생성되며, ***우리가 생성하는 모든 쓰레드 그룹은 main 쓰레드 그룹의 하위 쓰레드 그룹이다.***
- Thread의 쓰레드 그룹과 관련된 메서드
```
ThreadGroup getThreadGroup() //자신이 속한 쓰레드 그룹을 반환.
void uncaughtException(Thread t, Throwable e) // 쓰레드 그룹의 쓰레드가 처리되지 않은 예외에 의해 실행이 종료되었을 때, JVM에 의해 이 메서드가 자동적으로 호출된다.
```
## ※정리※
- 생성한 모든 쓰레드 그룹은 main 쓰레드 그룹 하위에 포함된다.
- 쓰레드 그룹을 지정하지 않은 쓰레드는 main 쓰레드 그룹에 포함된다.
- setMaxPriority() 메서드는 쓰레드가 쓰레드 그룹에 추가되기 이전에 호출되어야 한다.
- 쓰레드가 쓰레드 그룹에 속하게 되면, 그 쓰레드의 주소값이 쓰레드 그룹 내 저장되어 참조변수 없이 생성해도 가비지 컬렉터의 대상이 되지 않는다.<br><br>

# 데몬 쓰레드
## 1. 데몬쓰레드란?
- 다른 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드.
- **일반 쓰레드가 모두 종료 시 데몬 쓰레드는 자동으로 강제 종료된다.**
    - 보조하는 역할이기 때문.
- 대표적인 예 : 가비지 컬렉터, 워드프로세서의 자동저장 ...
- 데몬 쓰레드는 무한루프와 조건문을 이용하여 실행 후 대기하고 있다가
  특정 조건이 만족되면 수행하고 다시 대기하도록 작성한다.<br>
## 2. 데몬쓰레드 생성
- 일반 쓰레드의 작성 및 실행방법이 같으며 다만 쓰레드를 생성한 다음 실행 전에 setDaemon(true)를 호출하면 된다.
- 데몬 쓰레드가 생성한 쓰레드는 자동적으로 데몬쓰레드가 된다는 것도 알아두자.
```
boolean isDaemon() // 쓰레드가 데몬 쓰레드인지 확인, 데몬 쓰레드이면 true반환.
void setDaemon(boolean on) // 쓰레드를 데몬 쓰레드로 또는 사용자 쓰레드로 변경한다. 매개변수 on의 값을 true로 지정하면 데몬 쓰레드가 된다.
```
- 데몬 쓰레드로 만들지 않으면, 쓰레드가 종료되지 않고 무한 루프에 빠진다.
- setDaemon() 메서드는 반드시 start() 메서드 호출 전에 실행되어야한다.
    - 그렇지 않으면, IllegalThreadStateException 예외 발생.<br><br>

# 쓰레드의 실행제어
- 쓰레드의 스케줄링 관련 상태를 제어.<br>
## 쓰레드의 스케줄링과 관련된 메서드
- **static void sleep(long millis)** : 지정된 시간 동안 쓰레드를 일시정지 시킨다. 지정 시간이 지나고 자동으로 다시 실행대기 상태가 된다.
- **void join(long millis)** : 지정된 시간동안 쓰레드가 실행되도록 한다. 기존에 실행되던 쓰레드는 일시정지되고 지정 시간이 지나거나 해당 작업이 끝나면 join()을 호출한 쓰레드로 다시 돌아와 실행을 재개한다.
- **void interrupt()** : sleep() 또는 join()에 의해 일시정지 상태인 쓰레드를 다시 깨워서 실행대기 상태로 만드는데, InterruptedException 예외를 발생 시켜 일시정지 상태를 벗어나게 한다.
- **void stop()** : 쓰레드를 즉시 종료시킨다.
- **void suspend()** : 쓰레드를 일시정지시킨다.
- **void resume()** : suspend()에 의해 일시정지 상태에 있는 쓰레드를 실행대기 상태로 만든다.
- **static void yield()** : 실행 중에 자신에게 주어진 실행시간을 다른 쓰레드에게 양보(yield)하고 자신은 실행대기상태가 된다.<br>
## 쓰레드의 상태
- **NEW** : 쓰레드 생성된 후 start() 호출되기 전 상태.
- **RUNNABLE** : 쓰레드가 실행 가능한 상태(실행 대기 & 실행 중)
- **BLOCKED** : 동기화블록에 의해서 일시정지된 상태.(lock)
- **WATING** : unrunnable의 일시정지 상태.
- **TIMED_WAITING** : 일시정지 시간이 지정된 일시정지 상태.
- **TERMINATED** : 쓰레드의 작업이 종료된 상태.
### getState()
- 쓰레드의 상태를 확인할 수 있는 메서드(JDK 1.5)
- Thread.State 열거형 상수에 쓰레드 상태가 정의되어 있다.