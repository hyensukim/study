# 객체지향 프로그래밍2

# 상속과 다형성
## 상속
<br>

- 객체지향 프로그래밍이 유지 보수가 편하고 수정이 간편한 이유의 기반이 되는 기술.
- 예를 들어 설명하면, B 클래스가 A클래스를 상속 받으면 B클래스는 A클래스의 멤버변수나 메서드와 같은 클래스 멤버를 사용할 수 있다.

<br><Br>

* ### 클래스의 상속
<br>

![Alt text](https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA%2884%EC%8B%9C%EA%B0%84%29/8~10%EC%9D%BC%EC%B0%A8%289h%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D2/images/%EC%83%81%EC%86%8D1.png)
- 위 그림처럼 클래스 간의 상속 시 관계를 화살표로 표시한다.
- 클래스의 상속은 **extends** 라는 예약어를 사용한다.
- class B extends A
    - B 클래스가 A클래스를 상속 받다.
    - 상속 시 B가 구체적, A가 추상적인 클래스가 된다.
<br>

![Alt text](https://raw.githubusercontent.com/yonggyo1125/curriculum300H/main/1.JAVA%2884%EC%8B%9C%EA%B0%84%29/8~10%EC%9D%BC%EC%B0%A8%289h%20-%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D2/images/%EC%83%81%EC%86%8D2.png)
- 위 그림을 보면,
    - 포유류는 사람 보다 추삭적인 개념.
    - 사람은 포유류의 특징과 기능을 기본으로 추가적인 특징을 가진다.
    - 상속 관계에서 상위클래스가 추상적인 개념이고, 하위 클래스가 구체적인 클래스가 된다.

<br><br>

## super 예약어
<br>

- 상위 클래스의 자원을 사용할 수 있는 이유
    - 컴파일러가 컴파일 시 자동으로 생성자 내에 상위 클래스 생성자를 호출하게 되어 내부적으로
      상위 클래스의 자원을 포함한 하위 클래스 객체가 생성되어 상위 클래스의 자원에 접근이 가능한 것이다.
    
- B extends A 인경우, B()호출 -> A()호출, A 객체생성 -> B 객체 생성
1. super()
    - 상속 관계인 경우, 객체 생성 시 상위 객체 생성 이후 하위 객체가 생성된다.
    - 생성자 호출 순서 : 하위 클래스 생성자() -> 상위 클래스 생성자()
    - 객체 생성 순서 : 상위객체 생성 -> 하위객체 생성
    - 하위 객체 생성 시 자동 추가되는 것.
        1. 하위 클래스의 기본 생성자
        2. 하위 클래스 기본 생성자 내 상위 클래스 기본 생성자.
        - super() : 상위클래스의 객체를 생성하는 생성자 호출 예약어.
<br>

2. super 지역변수
    - 하위 객체와 함께 생성되는 상위 객체의 참조값을 저장한 지역변수.
<br><br>

## 다형성
- 상속 관계인 경우, 상위 클래스 타입의 참조 변수가 하위 클래스 객체를 참조할 수 있다.( ex 인간은 표유류 이다.)
<br>

### 형변환
- 다형성에 의해 하위 클래스 객체를 상위 클래스 타입의 변수가 참조할 경우 형변환이 발생한다.
    - 하위 클래스 -> 상위 클래스 : 묵시적 형변환
- 이와 반대로, 하위 클래스 타입의 변수가 상위 객체를 참조하는 경우, 상위 객체의 출처가 불분명하여 예외가 발생 할 수 있다.
    - 상위 클래스 -> 하위 클래스 : 명시적 형변환
- 이러한 경우, 출처를 확인하기 위해 *instanceof* 연산자를 사용하여 출처를 확인 후 형변환 해줘야 한다.

<br>

> #### 출처가 불분명하다는 말이 뭘까?

```
public class A{

}

public class B extends A{

}

public class C extends C{

}

Public class test{

    public static void main(String[] args){
        B b = new B(); // 객체 생성
        A a = b; // 가능. B -> A로 묵시적 형변환.

        //하지만, 반대의 경우, 출처가 확인되어야 함.
        //출처가 맞지 않은 경우 오류 발생함.
        if(A instanceof B){ // A가 B 클래스의 부모가 맞는가.
            B b = a;
        }
        /*
        C c = a; -> a는 B와 상속관계에 있음, C 클래스와는 무관함.
        이로 인해 오류가 발생함. -> 이런 경우를 방지하기 위해 instanceof 사용
        */
    }
}
```

<br><br>

## 메서드 오버라이드(재정의)
- 상속 관계에서 상위 클래스의 메서드를 하위 클래스에서 재정의한 것을 **오버라이드**라 한다.
    - 하위 객체에 재정의된 메서드는 클래스타입과는 무관하게 생성된 객체의 주소값에 따라 해당 메서드를 호출하게 된다.
    - 정확한 이유는 **가상 메서드** 필기에서 추가 설명되어 있음.
<br>

### 애너테이션
- 컴파일러에 정보를 전달하기 위한 목적을 가진 코드.(***기능은 절대 아님***)
- @Override : 해당 메서드가 오버라이드 된 메서드라고 컴파일러에 정보 전달.
- 컴파일러에서 해당 클래스의 상위 클래스에 동일한 이름의 메서드가 정의되어 있는지 확인 후 
  없는 경우 예외 발생함.
- 개발자의 실수를 방지하기 위한 것.

<br><br><br>

# final 예약어
### 변수 -> 상수
### 메서드 -> 재정의 불가
### 클래스 -> 상속 불가

<br><br><br>

# 추상 클래스(Abstract Class)

## 추상클래스의 목적
- 추상 클래스는 일반적으로 이 클래스를 상속 받은 하위 클래스에 정의해야 할 메서드를 알려주는 ***가이드라인***을 위한 클래스이다.
- 추상 클래스 내부에는 미구현된 메서드가 존재하며, 이러한 ***미구현된 메서드는 상속 받은 하위 클래스에서 구현해줘야 한다***
    - 구현하지 않을 경우, 오류가 발생한다.
- 또 하나의 목적은 추상 클래스 내부에 사용하는 멤버변수 또는 메서드를 정해놓고 상속 받은 클래스가 ***공유***할 수 있도록 한다.
<br>

## abstract 예약어
- 형식  
***`(public) abstract class 클래스명{ ...미구현 메서드 }`***
- 구현된 메서드 및 멤버변수 정의는 가능하나, 클래스 목적 상 미구현 메서드만 코딩하는게 일반적이다.
<br>

## 객체 생성이 불가능한 클래스
- 일반적으로 객체 생성이 불가능한 클래스이다.
- 하지만, 상속과 다형성을 통해 하위 클래스의 인스턴스를 만들어 클래스 타입으로서 사용은 할 수 있다.
    - 이렇게 생성된 객체는 ***추상 클래스 객체***라고 한다.

<br>

## ***Interface***
- 설계를 위한 클래스의 일종
- 객체 생성 및 멤버변수 선언이 불가능하다.
- 구현된 메서드 정의 시 오류 발생.
- 미구현된 메서드 정의시 ***public abstract***라는 내용이 자동으로 입력된다.
- 변수 선언시 ***public static final***이라는 내용이 자동 입력되어 정적상수로 선언된다.
<br>

### 인터페이스 내부 요소
- 정적 상수 : 객체 생성이 불가하여, 외부에서 접근 가능한 public static final 정적 상수만 선언.
- 미구현 메서드(추상 메서드)
- default 메서드  
상위 클래에서 구현한 메서드, 하위 클래스에서 구현하지 않아도 사용이 가능한 메서드이며, ***default*** 예약어를 붙여줘야 한다.
- static 메서드(정적)
- private 메서드
인터페이스 내부에서만 호출이 가능하며, 일반적으로 default 메서드 내부에 호출하여 default 메서드 호출 시 함께 호출되도록 사용한다.
<br>

### 인터페이스 상속
- 클래스에서 인터페이스 상속
    - `클래스명 implements 인터페이스명`
- 인터페이스 간 상속
    - `인터페이스명1 extends 인터페이스명2`
    - 클래스의 경우 2개 상속이 불가능하나, 인터페이스는 2개 이상 상속이 가능하다.
- 클래스에서 인터페이스 2개 상속
    - `클래스명 implements 인터페이스명1, 인터페이스명2`
    - 클래스의 경우 2개 상속이 불가능하나, 인터페이스는 2개 이상 상속이 가능하다.
    - 이러한 경우, 상위 인터페이스 두곳에 동일명의 미구현 메서드가 정의되어 있어도 상관없다.
    - 실제 구현은 하위 클래스에서 하기 때문이다.
    - 하지만, default 매서드의 경우 중복으로 정의시 인터페이스의 소유를 밝혀주지 않게되면 오류가 발생한다.