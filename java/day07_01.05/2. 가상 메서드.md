# 정적 바인딩 VS 동적 바인딩

> ## Binding
- 프로그램 구성 요소의 성격을 결정해 주는 시점.
- ex) 변수의 데이터 타입이 무엇인지 정해지는 시점.
<br>

### 정적 바인딩
- 컴파일 시점에 성격이 결정.
- ex) Java 컴파일 시에 static 요소의 데이터 타입이 결정.
- 장단점 : 컴파일 시간에 많은 정보가 결정되므로 실행 효율이 올라간다.
<br>

### 동적 바인딩
- 실행(runtime) 시점에 성격이 결정.
- ex) Java 객체의 경우 런타임 시점의 값에 따라 멤버 변수의 데이터 타입이 결정.
- 장단점 : 좀 더 자유롭게 변환이 가능함.
<br><br>

>## 함수의 바인딩
- 함수는 정의 및 컴파일 시 함수 코드가 메모리 어딘가 저장된다.
- 함수를 호출 시 함수 코드가 저장된 메모리 위치(참조값)이 필요하며 이를 참조하여 함수 코드를 실행하는 것을 **함수 바인딩**이라 한다.
<br>

### 함수 바인딩 방법
1. 정적 바인딩(일반 함수) : 컴파일 시점에 호출함수의 참조값이 결정되어 바인딩 되는것.
2. 동적 바인딩(가상 함수) : 실행 파일을 만들 때 참조값을 저장할 메모리를 비워둔 보류 상태 이다가 실행 시 결정되어 바인딩 되는것.
    - 단점 : 자료형 확인으로 인한 시간 지연 발생, 메모리 공간 낭비 => 가급적 정적 바인딩 사용.
<br>

### 함수의 동적 바인딩(가상 메서드) 사용 이유
- 단점이 있음에도 사용하는 이유는 클래스 타입에 상관없이 인스턴스에 따라 재정의된 함수 호출이 가능해지기 때문이다.(오버라이드)
<br><br>

# 가상 메서드(virtual method)
- 상속 관계에서 하위 클래스에서 재정의한 메서드를 호출 할 때, 호출되는 메서드는 인스턴스(객체)에 따라 결정되는 기능.
<br>

## 상세 설명
- 동일한 클래스 타입의 객체들은 하나의 메서드를 공유하여 사용한다.
    - 같은 로직을 구현하는데 여러개의 공간을 사용할 필요가 없기 때문이다.(효율성)
- **메서드 정의 및 컴파일** 시 각 메서드마다 참조값이 할당되며, **메서드 호출** 시 해당 참조값을 참조하여 메서드를 사용한다.
- 가상 메서드는 가상 메서드 테이블 내 메서드 호출 시 참조하는 참조값을 빈 공간으로 보류해놓은 뒤, runntime 시점에 각 인스턴스에 정의된 메서드의 참조값을 참조하도록 하여 동적으로 메서드를 사용하도록 한다.
  - 이러한 방식으로 인해 하위 클래스 객체의 메서드 오버라이드가 가능한 것이다.
- 재정의된 메서드는 가상 메서드 테이블에 인스턴스마다 다른 참조값을 가지고 있어 인스턴스마다 호출되는 내용이 다르다.
- 재정의되지 않은 메서드는 메서드 하나의 참조값을 공유하여 상위 클래스의 메서드를 하위에서도 호출하게 된다.
