# 스프링 DI(Dependenct Injection - 의존 주입) 복습
1. 의존이란?
    - 객체 A 내 기능이 객체 B의 메서드를 호출함으로서 구현된 경우, 이는 A 객체가 B 객체에게 의존했다라고 한다. 
2. DI를 통한 의존 처리
    - 의존하는 객체의 메서드를 호출하기 위해서는 의존 객체를 생성해야 하는데, 외부로 부터 의존객체를 주입 받는 것을
      의존 주입이라고 한다.
    - 의존 주입은 생성자식 매개변수 또는 Setter 메서드를 통해 외부로 부터 의존객체를 가져오는 것을 의미한다.
3. 객체 조립기
    - 동일한 객체로 부터 의존을 주입받는 경우, 의존 객체를 생성한 하나의 클래스를 별도로 정의하여 해당 클래스 내부에서
      각 기능들을 관리하는 것이 변화에 유연한 디자인이며, 이를 객체 조립기라고 한다.(ServiceManager)
    - 의존 객체의 기능을 확장해야 할 경우가 발생할 수 있는데, 이 때를 대비하여 각 객체의 의존 객체를 상속이 아닌 의존 객체
      타입의 변수를 선언하여 구성을 통해 확장을 열어두었다.
    - 따라서, 의존 객체의 확장 시 객체조립기의 구성요소인 의존 객체만 바꿔주면 기능 확장이 쉽게 수행된다.

# 스프링 프레임워크
- 핵심 기능 : 객체를 스프링 컨테이너에 담아 관리 해준다.
    - 스프링 자체에서 의존성 주입 및 객체 조립기 역할을 해준다.
- IOC : Inversion Of Control로 통제의 역전을 의미한다.
    - 원래 객체의 관리는 개발자가 통제했지만, 스프링 프레임워크의 등장으로 인해 통제의 주도권이 Spring으로 바뀌게
      되면서 객체 관리 통제가 역전된 것을 말한다.
- 스프링 컨테이너 핵심 클래스
    - AnnotationConfigApplicationContext
    - 관리할 객체 생성 및 설정을 애너테이션을 통해 수행한다.

# 애너테이션
1. @Configuration
    - 관리할 객체를 설정하는 설정 클래스 지정용 애너테이션.
    - Spring 컨테이너에서 관리할 객체의 정보를 갖고 있는 클래스.
2. @Bean
    - 관리할 객체를 지정하는 애너테이션.
    - 지정된 객체는 Bean이 되어 Spring 컨테이너에 담긴다.
    - @Bean으로 지정된 객체는 spring 컨테이너 안에 싱글톤 패턴의 객체 하나만 담긴다.
    - Bean 사용.
        1. AnnotationConfigApplicationConfig 객체 생성.
            - 생성자 매개변수로 @Configuration으로 지정한 객체 설정 클래스의 정보 입력.(Ctx.class)
        - BeanFactory 클래스의 인스턴스 메서드인 getBean("빈 이름", 의존 객체의 클래스 정보)을 호출.
            - 이때 의존 객체의 클래스 정보가 하나인 경우(@Qualifier 애너테이션으로 구분하지 않은 객체) Bean 이름은 생략이 가능하다.
            - 빈이름은 객체 호출 메서드명과 동일하다.
3. @Autowired(가장중요)
    - 자동 의존성 주입 애너테이션.
    - 의존성 주입 방법
        - 멤버변수 -> 변수로 선언하여 구성을 통해 기능 확장을 위한 의존성 주입.
        - setter 메서드의 매개변수 -> 확장을 열기위해 메서드의 매개변수로 받고, 
        - 생성자의 매개변수
        - Optional(래퍼 클래스 -> NullPointException 발생하지 않도록 감싸주는 래퍼클래스)
    -  의존성 자동 주입
        1. @Autowired 애너테이션을 이용한 의존성 자동 주입.
         - spring 컨테이너 내 관리되는 bean을 찾아서 메서드를 자동 호출하여 의존성을 주입해준다.
        2. 일치하는 bean이 없는 경우 NoSuchBeanDefinitionException 예외 발생.
        3. @Qualifier 애너테이션을 이용한 의존 객체 선택
    - @Qualifier("명칭") 
        - 설정 클래스에 bean 객체가 동일한게 2개 이상인 경우 충돌로 인해 오류가 발생하며, 이때 구분 명칭을 나타내기 위한 애너테이션.
        - 이는 @Qualifier()를 사용하여 @Autowired() 사용하는 부분에 @Qualifier("명칭") 애너테이션으로 명시해줘야 한다.
        - bean은 싱글톤 패턴의 객체로 spring 컨테이너에 하나만 존재한다. 따라서 메서드명은 달라도 같은 객체를 반환할 경우,
          spring 컨테이너 입장에서는 동일한 bean으로 인식하여 어떤 객체를 선택해야 하는지 몰라서 충돌이 발생한다.
    - @Autowired(required = ture)인 경우
        -bean(의존 객체) 이(가) 반드시 있어야 하며, 없는 경우 오류 발생.
    - @Autowired(reuqired = false)인 경우
        - 컨테이너 안에 해당 bean이 존재하지 않는 경우, 의존하는 메서드를 호출 하지 않게 된다.
    - @Autowired - @Nullable : 의존하고 있는 메서드를 호출하지만, 매개변수로 bean(객체)이 아닌 null을 대입한다.
4. @Import
    - 설정 클래스에서 다른 설정 클래스를 포함할 때 사용하는 애너테이션.
    - 설정 파일이 2개인 경우, 하나의 설정파일에 임포트 해놓으면, AnnotaionConfigApplicationContext 객체 생성 시 하나의
      설정파일만 등록해도 임포트한 나머지 설정파일도 같이 등록할 수 있다.
    - 여러 개를 import 할 경우, ...(가변인자)로서 {1Ctx.class,2Ctx.class} 이런식으로 여러개를 import하면 된다.

# 컴포넌트 스캔(자동 bean 설정)
- 설정할 bean이 많을 경우 일일히 bean 설정하게 되면 코드가 길어지고 비효율적으로 관리하게 된다.
- 이를 위해 컴포넌트 스캔 애너테이션을 통해 자동으로 bean 설정이 가능하다.

1. @ComponentScan(backPages="패키지명")
    - 지정된 패키지 하위의 모든 패키지 내 클래스 검색 범위
    - 클래스 상위에 @Component 또는 @Service 애너테이션 지정을 해놓은 경우, ComponentScan 범위
      내에 해당 클래스는 컨테이너에 자동 bean 등록되어 관리 대상이 된다.
    - @Component와 @Service는 이름만 다를 뿐 제공하는 정보는 똑같다.